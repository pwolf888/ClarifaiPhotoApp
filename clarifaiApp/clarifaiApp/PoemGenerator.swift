//
//  NewPoemGenerator1.swift
//  clarifaiApp
//
//  Created by 李阳 on 29/1/18.
//  Copyright © 2018 partywolfAPPS. All rights reserved.
//

import Foundation

class PoemGenerator{
    var rules:[String] = []
    var poemStructures:[[String]] = [[]]
    var partOfSentence:[String:[[String]]] = [:]
    var nouns:[String : [String]] = [:]
    var defaultPoemIndex = -1
    var tagOne = ""
    
    init() {
        readDataFromJsonFile()
    }
    
    // Read the json files
    func readDataFromJsonFile(){
        
        // Poem structures json file
        var path = Bundle.main.path(forResource: "poem_structure", ofType: "json")
        var url = URL(fileURLWithPath: path!)
        
        do{
            let data = try Data(contentsOf: url)
            let dic = try JSONDecoder().decode([String:[String]].self, from: data)
            //print(dic)
            
            rules = Array(dic.keys)
            
            poemStructures = Array(dic.values)
        }
        catch{}
        
        // Part of sentence json file
        path = Bundle.main.path(forResource: "part_of_sentence", ofType: "json")
        url = URL(fileURLWithPath: path!)
        do{
            let data = try Data(contentsOf: url)
            partOfSentence = try JSONDecoder().decode([String:[[String]]].self, from: data)
        }
        catch{}
        
        // Noun json file
        path = Bundle.main.path(forResource: "noun", ofType: "json")
        url = URL(fileURLWithPath: path!)
        do{
            let data = try Data(contentsOf: url)
            nouns = try JSONDecoder().decode([String:[String]].self, from: data)
            //print(nouns)
        }
        catch{}
    }
    
    // Generate the poem
    func generateTopicalPoem(tags: [String])->String{
        
        // TagOne is taken from the tags generated by clarifai
        // If the first tag holds "no person" discard and use next tag
        tagOne = (tags[0] == "no person" ? tags[1] : tags[0])     //only used for no poem
        
        // TagsCopy = tags from clarifai
        var tagsCopy = tags
        var poem = ""
        var poemOptions: [Int : String] = [:]
        
        // Create default poem
        tagsCopy.append("default")
        
        // Loop through rules dictionary
        for i in 0..<rules.count{
            // Check Rule function passing in the rules array and the tags list
            // Checking to see which of the first 3 tags are suited for the poem
            // r = result
            let r = checkRule(rule: rules[i], tags: tagsCopy)
            
            // If result.0 is true
            if(r.0){
                // Checks the rules for each component inside Poem structure - ie @animal@
                let subRules = rules[i].components(separatedBy: "@")
                
                //
                poemOptions[r.1] = processPoemStructure(index: i ,subRule: subRules[1],topic: r.2, items: r.3) + "\n\n"
            }
        }
        
        
        // Print to the console the poetential poems chosen
        for p in poemOptions.values{
            print(p)
        }
        
        var min = 100
        for key in poemOptions.keys{
            if(key<min){
                min = key
            }
        }
        
        // The final poem
        poem = formatPoem(rawPoem: poemOptions[min]!)
        
        return poem
    }
    
    // Decide which poem to use
    func checkRule(rule: String, tags: [String]) -> (Bool, Int, String, [String]){
        // Poem_Structure.json - @animal@
        var subRules = rule.components(separatedBy: "@")
        // The first word that matches holds priority in sub rules - tag animal - @animal@
        let priority = Int(subRules[0])
        // Some poems have several similar topics - @athlete|sport|exercise@sport
        let subSubRules = subRules[1].components(separatedBy: "|")
        // If there are multiple categories - @landscape|sea|nature@landscape" << landscape is second category
        let category = subRules[2]
        // Results that store the information for rules of the powm structure
        var result:(Bool, Int, String, [String]) = (false, 0, "", [])
        
        // Check the pipe "|" seperated tags if it contains the tag chosen
        for e in subSubRules{
            // Make it priority sentence structure if it contains the tag chosen the break out
            if(tags.contains(e)){
                result.0 = true
                result.1 = priority!
                result.2 = e
                break
            }
        }
        
        // if the second category is not nil
        if(category != "nil"){
            // Choose some random nouns that have the corresponding category
            for item in nouns[category]!{
                // Add the extra nouns to the results array
                if(tags.contains(item)){
                    result.3.append(item)
                }
            }
        }
        
        return result
    }
    
    // Process the Poem
    func processPoemStructure(index: Int, subRule:String, topic: String, items: [String]) -> String{
        // Contents of poem
        var poem = ""
        // Cycle through poem structures index
        let temp = poemStructures[index]
        //
        let poemStructure = temp[Int(arc4random_uniform(UInt32(temp.count)))]
        // Create an index of all words inside poem seperated by a space
        var partOfPoem = poemStructure.components(separatedBy: " ")
        var counter = 0
        
        // Go through the poems index
        for i in 0..<partOfPoem.count{
            var t = partOfPoem[i]
            var firstCharacter = ""
            
            // Set the start of index if there is no space
            if(t != ""){
                firstCharacter = String(t[t.startIndex])
            }
            
            // If first char is @ replace it with
            if(firstCharacter == "@"){
                // Remove word - @1
                t.removeFirst()
                // Replace with a word from part of sentence json file
                // Index from subRule
                let t1 = partOfSentence[subRule]![Int(t)!]
                // Get a reanom word from the collections
                partOfPoem[i] = t1[Int(arc4random_uniform(UInt32(t1.count)))]
            }
            
            // If first char is *
            if(firstCharacter == "*"){
                // The first word will have the topic added - Dog
                partOfPoem[i] = topic
            }
            
            // If the first char is #
            if(firstCharacter == "#"){
                // Remove word - #food
                t.removeFirst()
                
                // Add the extra chosen nouns to the sentence if room left
                if(counter < items.count){
                    partOfPoem[i] = items[counter]
                    counter += 1
                }
                else{
                    // Add words to sentence
                    let ch = t[t.startIndex]
                    
                    if(ch == "@"){
                        t.removeFirst()
                        let t1 = partOfSentence[subRule]![Int(t)!]
                        partOfPoem[i] = t1[Int(arc4random_uniform(UInt32(t1.count)))]
                    }
                    else{
                        partOfPoem[i].removeFirst()
                    }
                }
            }
            
            //only for no poem
            if(firstCharacter == "$"){
                partOfPoem[i] = tagOne
            }
        }
        
        // Join all of it together as one string
        poem = partOfPoem.joined(separator: " ")
        
        return poem
    }
    
    // Format the poem for output
    func formatPoem(rawPoem: String) -> String{
        var poem = ""
        let arr = Array(rawPoem)
        
        
        for i in 0..<arr.count-1{
            if(arr[i] == " " && ((arr[i+1] == ","||arr[i+1] == "." || arr[i+1] == "!") || arr[i - 1] == "\n")){
                continue
            }
            else{
                poem.append(arr[i])
            }
        }
        poem.append(arr[arr.count-1])
        
        return poem
    }
}

